#include <stdio.h>
// Provides printf().
#include <system.h>
// Provides symbols for the base addresses of all peripherals (e.g.
// PERFORMANCE_COUNTER_0_BASE and LEDS_BASE and the CPU frequency
// ALT_CPU_FREQ. It also includes io.h, which provides IO
// intrinsics IORD() and IOWR().
#include <alt_types.h>
// Provides the standard types, such as alt_u32.
#include <io.h>
// Provides the IORD() and IOWR() instrinsics for the ldwio and stwio instructions.

//global
float pwm_frequency = 10e3f;
float dim_period = 2.0f;



alt_u64 pwm_period_in_cycles = (alt_u64)(pwm_period * (float)ALT_CPU_FREQ);
float current_duty_cycle = fabs((cycle_counter % dim_period_in_cycles)*(-2.f/dim_period_in_cycles) + 1.0f);



void read() {
    // Read the counter. Begin with declaring a 64-bit value that can be split between
    // high and lo halves.
    union {
        struct {
        alt_u32 lo;
        alt_u32 hi;
        } parts;
        alt_u64 raw;
    } cnt;

    // Read upper 32 bits
    cnt.parts.hi = IORD(PERFORMANCE_COUNTER_0_BASE,1);

    // Read lower 32 bits
    cnt.parts.lo = IORD(PERFORMANCE_COUNTER_0_BASE,0);
    // Refer to both halves as "cnts.raw"
}


//my thinking 
int main(int argc, char *argv[]) {
    //turn all lights on
    IOWR(LEDS_BASE,0,0x3FFFFFF); 

    // Start the counter; do this only once at the beginning of your main() function
    // Note that this writes the value 0 to register 1 on the performance counter module.
    // This assumes you used the default name for the performance counter, which is
    // "performance_counter_0".

    IOWR(PERFORMANCE_COUNTER_0_BASE,1,0);
    while (true) {
        if(pwm_period_in_cycles < (dim_period/2)) {
            current_duty_cycle = current_duty_cycle*(-.1);
        }
        else if (pwm_period_in_cycles >= (dim_period/2)) {
            current_duty_cycle = current_duty_cycle*(.1);
        }
    }
}



