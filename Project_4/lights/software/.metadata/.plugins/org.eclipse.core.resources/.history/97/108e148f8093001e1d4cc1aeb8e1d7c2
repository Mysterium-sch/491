#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "system.h"
#include "altera_avalon_pio_regs.h"
#include "alt_types.h"
#include "sys/alt_stdio.h"
#include <system.h>
#include <stdbool.h>
#include <alt_types.h>
#include <io.h>
#include <math.h>

float pwm_frequency = 10e3f;
float dim_period = 5.0f;
float* ptr;
int size = 1;

int main()
{
	time_t t;
	srand((unsigned) time(&t));
	unsigned int motor_base = 0x0;
    float T_s = 0.1;
    float k_p = 1.0;
    float k_d = 0.1;
    float k_i = 0.01;
    float setpoint = 1000.0;  //speed in RPM
    int cycle = 0;
//    char right[] = "right";
//    char left[] = "left";
    //int cur_time = 0;

	// global variables
	pwm_frequency = 10e3f;
	usleep (250000);
	//MOTOR_0_BASE
	//IOWR(0x0,0,0.5);
	printf ("Program running Motor...\n");

	unsigned int prev_control_action_cycles = 0;
    float error = 0.0;
    float error_old = 0.0;
    float error_accum = 0.0;
    float error_delta = 0.0;

    while (1) {
    	//cur_time = cur_time+1;
        // Determine if we should perform control
    	//The software should log the value of time, motor input, and motor speed and direction at 1/T_s Hz
    	//sampling rate, and then dump this log to the terminal before the program ends.
        int cycle_counter = cycle;
        int cycles_since_last_control = cycle_counter - prev_control_action_cycles;
        float time_since_last_control = cycles_since_last_control / (float)pwm_frequency;
        float cur_time= cycle_counter / (float)pwm_frequency;

        // Perform control
        if (time_since_last_control >= T_s) {
            float current_motor_rpm = IORD(motor_base,0);

            error_old = error;
            error = setpoint - current_motor_rpm;
            error_accum += error;
            error_delta = error - error_old;

            float motor_input = k_p * error + k_d * error_delta + k_i * error_accum;
            IOWR(motor_base,0,motor_input);
            prev_control_action_cycles = cycle_counter;

//            printf("time: %i\n", cycle);
        	ptr[size] = current_motor_rpm;
        	size = size +1;
//        	printf("input: %3.2f\n", motor_input);
//        	if(motor_input > 0) {
//        	    printf("dir: %3.2f\n", 0.0);
//        	} else {
//        		printf("dir: %3.2f\n", 1.0);
//        	}

        }
        cycle = cycle +1;
        if (cycle > 2000000) {
            IOWR(motor_base,0,0);
        	break;
        }
	}

    for(int i = 0; i <size; i++) {
    	printf("rpm: %3.2f\n", ptr[i]);
    }

	return 0;
}
